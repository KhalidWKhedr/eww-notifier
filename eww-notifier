#!/home/khalidwaleedkhedr/.local/share/eww-notifier-venv/bin/python3
from pydbus import SessionBus
from gi.repository import GLib, Gio
import json
import os
import sys
import requests
import shutil
import logging
import hashlib
import time
import signal
import threading
from typing import List, Dict, Any, Optional, Tuple
from pathlib import Path
from datetime import datetime, timedelta
from concurrent.futures import ThreadPoolExecutor
from functools import partial

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S',
    handlers=[
        logging.FileHandler(Path.home() / ".cache/eww_notifier.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# Constants
MAX_NOTIFS = int(sys.argv[1]) if len(sys.argv) > 1 else 5
NOTIF_PATH = Path.home() / ".cache/eww_notifications.json"
ALBUM_ART_DIR = Path.home() / ".cache/spotify_album_arts"
ALBUM_ART_CACHE = ALBUM_ART_DIR / "url_cache.json"
ALBUM_ART_METADATA = ALBUM_ART_DIR / "metadata.json"

# Icon search paths
ICON_DIRS = [
    "/usr/share/icons/Papirus/",
    "/usr/share/icons/hicolor/",
    "/usr/share/pixmaps/",
    "/usr/share/icons/",
    str(Path.home() / ".local/share/icons/"),
    str(Path.home() / ".icons/"),
    "/usr/share/applications/",
]

# Icon extensions and sizes
ICON_EXTENSIONS = [".svg", ".png", ".xpm"]
ICON_SIZES = ["scalable", "512", "256", "128", "96", "64", "48", "32", "24", "16"]

# Cache settings
MAX_CACHE_SIZE_MB = 100  # Maximum cache size in megabytes
MAX_CACHE_AGE_DAYS = 30  # Maximum age of cached files in days
CLEANUP_INTERVAL_HOURS = 24  # How often to run cleanup
MAX_RETRIES = 3  # Maximum number of retries for operations
RETRY_DELAY = 1.0  # Delay between retries in seconds

# Global state
notif_store: List[Dict[str, Any]] = []
album_art_cache: Dict[str, str] = {}
album_art_metadata: Dict[str, Dict[str, Any]] = {}
last_cleanup_time: float = 0
executor = ThreadPoolExecutor(max_workers=4)

def setup_signal_handlers():
    """Set up signal handlers for graceful shutdown."""
    def handle_signal(signum, frame):
        logger.info(f"Received signal {signum}, shutting down...")
        executor.shutdown(wait=True)
        sys.exit(0)
    
    signal.signal(signal.SIGINT, handle_signal)
    signal.signal(signal.SIGTERM, handle_signal)

def get_file_size_mb(path: Path) -> float:
    """Get file size in megabytes."""
    return path.stat().st_size / (1024 * 1024)

def get_cache_size() -> float:
    """Get total size of album art cache in megabytes."""
    total_size = 0
    for file in ALBUM_ART_DIR.glob("album_art_*.jpg"):
        total_size += get_file_size_mb(file)
    return total_size

def load_album_art_cache() -> None:
    """Load the album art URL cache and metadata from disk."""
    global album_art_cache, album_art_metadata
    try:
        if ALBUM_ART_CACHE.exists():
            with open(ALBUM_ART_CACHE, 'r') as f:
                album_art_cache.update(json.load(f))
        if ALBUM_ART_METADATA.exists():
            with open(ALBUM_ART_METADATA, 'r') as f:
                album_art_metadata.update(json.load(f))
    except Exception as e:
        logger.error(f"Failed to load album art cache: {e}")

def save_album_art_cache() -> None:
    """Save the album art URL cache and metadata to disk."""
    try:
        ALBUM_ART_CACHE.parent.mkdir(parents=True, exist_ok=True)
        with open(ALBUM_ART_CACHE, 'w') as f:
            json.dump(album_art_cache, f, indent=2)
        with open(ALBUM_ART_METADATA, 'w') as f:
            json.dump(album_art_metadata, f, indent=2)
    except Exception as e:
        logger.error(f"Failed to save album art cache: {e}")

def cleanup_old_files() -> None:
    """Remove old and unused album art files."""
    try:
        current_time = time.time()
        cutoff_time = current_time - (MAX_CACHE_AGE_DAYS * 24 * 60 * 60)
        
        # Get list of files to remove
        files_to_remove = []
        for file in ALBUM_ART_DIR.glob("album_art_*.jpg"):
            if file.stat().st_mtime < cutoff_time:
                files_to_remove.append(file)
        
        # Remove files and update cache
        for file in files_to_remove:
            file.unlink()
            # Remove from cache and metadata
            for url, path in list(album_art_cache.items()):
                if path == str(file):
                    del album_art_cache[url]
                    if url in album_art_metadata:
                        del album_art_metadata[url]
        
        save_album_art_cache()
        logger.info(f"Cleaned up {len(files_to_remove)} old album art files")
    except Exception as e:
        logger.error(f"Failed to cleanup old files: {e}")

def enforce_cache_size_limit() -> None:
    """Ensure cache size doesn't exceed the limit by removing oldest files."""
    try:
        while get_cache_size() > MAX_CACHE_SIZE_MB:
            # Find oldest file
            oldest_file = min(
                ALBUM_ART_DIR.glob("album_art_*.jpg"),
                key=lambda x: x.stat().st_mtime,
                default=None
            )
            if oldest_file:
                # Remove from cache and metadata
                for url, path in list(album_art_cache.items()):
                    if path == str(oldest_file):
                        del album_art_cache[url]
                        if url in album_art_metadata:
                            del album_art_metadata[url]
                oldest_file.unlink()
                logger.info(f"Removed oldest album art to maintain cache size limit: {oldest_file}")
            else:
                break
        
        save_album_art_cache()
    except Exception as e:
        logger.error(f"Failed to enforce cache size limit: {e}")

def check_cleanup() -> None:
    """Check if cleanup is needed and perform it if necessary."""
    global last_cleanup_time
    current_time = time.time()
    if current_time - last_cleanup_time > (CLEANUP_INTERVAL_HOURS * 60 * 60):
        cleanup_old_files()
        enforce_cache_size_limit()
        last_cleanup_time = current_time

def clear_cache() -> None:
    """Clear the entire album art cache."""
    try:
        # Remove all album art files
        for file in ALBUM_ART_DIR.glob("album_art_*.jpg"):
            file.unlink()
        
        # Clear cache and metadata
        album_art_cache.clear()
        album_art_metadata.clear()
        
        # Save empty cache
        save_album_art_cache()
        logger.info("Album art cache cleared")
    except Exception as e:
        logger.error(f"Failed to clear cache: {e}")

def save_notifications() -> None:
    """Save notifications to the cache file."""
    try:
        NOTIF_PATH.parent.mkdir(parents=True, exist_ok=True)
        with open(NOTIF_PATH, "w") as f:
            json.dump(notif_store, f, indent=2)
    except Exception as e:
        logger.error(f"Failed to save notifications: {e}")

def get_theme_icon(icon_name: str) -> Optional[str]:
    """Get icon path using Gio's theme icon lookup."""
    try:
        theme = Gio.IconTheme.get_default()
        icon = theme.lookup_icon(icon_name, 48, 0)
        if icon:
            return icon.get_filename()
    except Exception as e:
        logger.debug(f"Failed to get theme icon for {icon_name}: {e}")
    return None

def get_desktop_icon(app_id: str) -> Optional[str]:
    """Get icon from desktop file."""
    try:
        desktop_paths = [
            Path.home() / ".local/share/applications",
            Path("/usr/share/applications"),
            Path("/usr/local/share/applications")
        ]
        
        for path in desktop_paths:
            desktop_file = path / f"{app_id}.desktop"
            if desktop_file.exists():
                with open(desktop_file, 'r') as f:
                    for line in f:
                        if line.startswith('Icon='):
                            icon_name = line.strip().split('=')[1]
                            return resolve_icon_path(icon_name)
    except Exception as e:
        logger.debug(f"Failed to get desktop icon for {app_id}: {e}")
    return None

def resolve_icon_path(icon: str) -> str:
    """Resolve the full path of an icon file with improved search logic."""
    if not icon:
        return ""
    
    # If it's already an absolute path and exists, return it
    if os.path.isabs(icon) and os.path.exists(icon):
        return icon
    
    # Try theme icon lookup first
    theme_icon = get_theme_icon(icon)
    if theme_icon:
        return theme_icon
    
    # Try desktop file lookup for application icons
    if '.' in icon:  # Likely an application ID
        desktop_icon = get_desktop_icon(icon)
        if desktop_icon:
            return desktop_icon
    
    # Search in icon directories
    for directory in ICON_DIRS:
        if not os.path.exists(directory):
            continue
            
        # First try exact match
        for ext in ICON_EXTENSIONS:
            file_name = icon + ext
            if os.path.exists(os.path.join(directory, file_name)):
                return os.path.join(directory, file_name)
        
        # Then try with sizes
        for size in ICON_SIZES:
            for ext in ICON_EXTENSIONS:
                file_name = f"{icon}-{size}{ext}"
                if os.path.exists(os.path.join(directory, file_name)):
                    return os.path.join(directory, file_name)
        
        # Finally, search recursively
        for root, _, files in os.walk(directory):
            for ext in ICON_EXTENSIONS:
                file_name = icon + ext
                if file_name in files:
                    return os.path.join(root, file_name)
    
    # If all else fails, try to find a generic icon
    generic_icons = ["application-x-executable", "text-x-generic", "image-x-generic"]
    for generic_icon in generic_icons:
        theme_icon = get_theme_icon(generic_icon)
        if theme_icon:
            return theme_icon
    
    logger.warning(f"Could not find icon for: {icon}")
    return ""

def download_album_art(url: str, art_path: Path) -> bool:
    """Download album art with retry logic."""
    for attempt in range(MAX_RETRIES):
        try:
            r = requests.get(url, stream=True, timeout=3)
            if r.status_code == 200:
                with open(art_path, "wb") as f:
                    shutil.copyfileobj(r.raw, f)
                return True
        except Exception as e:
            logger.error(f"Failed to download album art (attempt {attempt + 1}/{MAX_RETRIES}): {e}")
            if attempt < MAX_RETRIES - 1:
                time.sleep(RETRY_DELAY)
    return False

def get_spotify_album_art() -> str:
    """Fetch and save Spotify album art with caching."""
    try:
        # Check if cleanup is needed
        check_cleanup()
        
        bus = SessionBus()
        spotify = bus.get("org.mpris.MediaPlayer2.spotify", "/org/mpris/MediaPlayer2")
        metadata = spotify.Metadata
        url = metadata.get("mpris:artUrl", "")
        
        if not url.startswith("https://"):
            return ""

        # Check if we already have this URL cached
        if url in album_art_cache:
            cached_path = album_art_cache[url]
            if os.path.exists(cached_path):
                # Update last accessed time
                album_art_metadata[url] = {
                    'last_accessed': time.time(),
                    'access_count': album_art_metadata.get(url, {}).get('access_count', 0) + 1
                }
                save_album_art_cache()
                return cached_path

        # Create a unique filename based on the URL
        url_hash = hashlib.md5(url.encode()).hexdigest()
        art_path = ALBUM_ART_DIR / f"album_art_{url_hash}.jpg"

        # Download and save the new album art
        if download_album_art(url, art_path):
            # Update cache and metadata
            album_art_cache[url] = str(art_path)
            album_art_metadata[url] = {
                'last_accessed': time.time(),
                'access_count': 1,
                'size_mb': get_file_size_mb(art_path)
            }
            save_album_art_cache()
            
            # Check cache size after adding new file
            enforce_cache_size_limit()
            
            return str(art_path)
    except Exception as e:
        logger.error(f"Failed to fetch MPRIS album art: {e}")
    return ""

class NotificationService:
    """
    <node>
      <interface name="org.freedesktop.Notifications">
        <method name="Notify">
          <arg type="s" name="app_name" direction="in"/>
          <arg type="u" name="replaces_id" direction="in"/>
          <arg type="s" name="app_icon" direction="in"/>
          <arg type="s" name="summary" direction="in"/>
          <arg type="s" name="body" direction="in"/>
          <arg type="as" name="actions" direction="in"/>
          <arg type="a{sv}" name="hints" direction="in"/>
          <arg type="i" name="expire_timeout" direction="in"/>
          <arg type="u" name="id" direction="out"/>
        </method>
        <method name="CloseNotification">
          <arg type="u" name="id" direction="in"/>
        </method>
        <method name="GetCapabilities">
          <arg type="as" name="capabilities" direction="out"/>
        </method>
        <method name="GetServerInformation">
          <arg type="s" name="name" direction="out"/>
          <arg type="s" name="vendor" direction="out"/>
          <arg type="s" name="version" direction="out"/>
          <arg type="s" name="spec_version" direction="out"/>
        </method>
      </interface>
    </node>
    """
    def Notify(self, app_name: str, replaces_id: int, app_icon: str, summary: str, body: str,
               actions: List[str], hints: Dict[str, Any], expire_timeout: int) -> int:
        """Handle incoming notifications."""
        try:
            if app_name.lower() == "spotify":
                resolved_icon = get_spotify_album_art()
            else:
                resolved_icon = resolve_icon_path(app_icon)

            notif = {
                "app": app_name,
                "icon": resolved_icon,
                "summary": summary,
                "body": body,
                "timestamp": time.time()
            }

            logger.info(f"Notification received:\n"
                       f"    App: {app_name}\n"
                       f"    Summary: {summary}\n"
                       f"    Body: {body}\n"
                       f"    Icon: {resolved_icon if resolved_icon else 'None'}")

            notif_store.insert(0, notif)
            if len(notif_store) > MAX_NOTIFS:
                notif_store.pop()

            save_notifications()
            return 0
        except Exception as e:
            logger.error(f"Error processing notification: {e}")
            return 1

    def CloseNotification(self, id: int) -> None:
        """Handle notification close requests."""
        logger.info(f"Notification with ID {id} closed")

    def GetCapabilities(self) -> List[str]:
        """Return supported notification capabilities."""
        return ["body", "icon"]

    def GetServerInformation(self) -> tuple:
        """Return server information."""
        return "eww-notifier", "custom", "1.0", "1.2"

def main() -> None:
    """Main entry point."""
    try:
        # Set up signal handlers
        setup_signal_handlers()
        
        # Load album art cache at startup
        load_album_art_cache()
        
        # Initial cleanup check
        check_cleanup()
        
        bus = SessionBus()
        bus.publish("org.freedesktop.Notifications", NotificationService())
        logger.info("📬 Listening for notifications on DBus...")
        GLib.MainLoop().run()
    except Exception as e:
        logger.error(f"Failed to start notification service: {e}")
        sys.exit(1)
    finally:
        executor.shutdown(wait=True)

if __name__ == "__main__":
    main()
